Category: Web exploitation

Points: 300

Author: Yahaya Meddy
### Description
A university's online registration portal asks students to upload their ID cards for verification. The developer put some filters in place to ensure only image files are uploaded but are they enough? Take a look at how the upload is implemented. Maybe there's a way to slip past the checks and interact with the server in ways you shouldn't.

Additional details will be available after launching your challenge instance.

---
### Hints
1: Apache can be tricked into executing non-PHP files as PHP with a `.htaccess` file.

2: Try uploading more than just one file.

---
### Solution
![](attachments/Pasted%20image%2020251002185550.png)

D'après l'application web fournie par le challenge, nous comprenons qu'il faudra exploiter une `file upload vulnerability`.  Le problème ici, c'est que le trick du `.php` déguisé en `.jpg` et toutes les autres techniques du genre ne fonctionnent pas. D'après le premier indice, nous devons exploiter le fichier `.htaccess` pour que l'application nous permette d'exécuter des fichiers non php en tant que fichier php.

Pour ce faire, nous pouvons utiliser [BurpSuite](https://portswigger.net/burp/communitydownload) ou [ZAP](https://www.zaproxy.org/). Dans ce write-up, BurpSuite sera utilisé.

#### Phase 1 : POST

- Préparer un fichier avec une extension aléatoire. On choisira`.l337`. On l'appellera `payload.l337`. Il contiendra la `PoC` ci-dessous :

```php
<?php system('id'); ?>
```

- Préparer un fichier nommé `.htaccess` avec pour contenu : 

```txt
AddType application/x-httpd-php .l337
```

Qu'est-ce que cela veut dire ? En fait, nous forçons le serveur à considérer les fichier `.l337` comme des fichiers `.php`.

- Upload le fichier `.htaccess`, intercepter la requête et changer `application/octet-stream` en `text/plain`. Pourquoi ? Le fichier `.htaccess` est par défaut un fichier texte.

![](attachments/Pasted%20image%2020251002193433.png)
- Upload le fichier `payload.l337`, envoyer la requête vers `Repeater` et renommé l'onglet `POST`.

![](attachments/Pasted%20image%2020251002194135.png)

#### Phase 2 : GET

- Allez à `images/payload.1337` et observer le résultat

![](attachments/Pasted%20image%2020251002194413.png)

Ça marche !

- Rechercher la requête `GET` , l'envoyer vers `Repeater` et nommé l'onglet `GET`.

#### Phase 3: Trouver le flag

Si tout à été fait correctement, on devrait avoir un setup comme ceci :

- Pour `POST`

![](attachments/Pasted%20image%2020251002195030.png)

- Pour `GET`

![](attachments/Pasted%20image%2020251002195149.png)

Nous allons finalement upload plusieurs fichiers à partir de `POST` et voir la réponse grâce à `GET`.
Par exemple, nous pouvons remplacer `payload.1337` par `payload1.1337` et au lieu de faire `id`, nous ferons un `ls -la`.

- `POST

![](attachments/Pasted%20image%2020251002195722.png)

- `GET`

![](attachments/Pasted%20image%2020251002195825.png)

On refait la même manœuvre cette fois-ci en utilisant `find / -name flag.txt 2>/dev/null` pour trouver le chemin vers le flag et `cat` pour lire son contenu.

![](attachments/Pasted%20image%2020251002201000.png)

GG!